---
title: "Software dependancy analysis"
author: "C. Mimeault"
date: "January 3, 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
# using R version 4.0.3 (2020-10-10)
```

```{r libraries, include=FALSE}
library(tidyverse)
library(here) # to read csv files with the function here
library(lubridate)
library(semver) # to extract the version numbers into separate columns
library(formattable) # to format tables
library(cowplot) # to plot figures side by side
library(dplyr, warn.conflicts = FALSE)
options(dplyr.summarise.inform = FALSE)
library(hms) # to extract the time
```

## Context

Open source projects rely on libraries that get updated regularly. While not all updates require code changes, some do. According to [semantic versioning](https://semver.org), versions are numbered incrementally according to the type of change. A "MAJOR version" signifies incompatible API changes, a "MINOR version" signifies added functionality in a backwards compatible manner, and a "PATCH version" signifies backwards compatible bug fixes. Additionally, the label "pre-release" can also be used, and is defined as a version that indicates "...that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version."

In this project, I explored the number and frequency of updates in a project currently under development to characterize the update requirements once the project will be "done" and in production. I used the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) from the frontend of Government of Canada's Tracker project as a representative example of a modern software project. Refer to the Methods section at the end of this post for details on the steps to gather and to clean the data.

```{r, include=FALSE}
packages <- read_csv(here("data", "processed", "nodejs.csv"), col_names = c("package_name", "version_number", "time_stamp"))
```

```{r, include=FALSE}
data <- packages %>%
  filter(version_number != "created") %>%
  filter(version_number != "modified")
```

```{r, include=FALSE}
data <- data %>%
  mutate(
    date = as.Date(time_stamp, "%Y/%m/%d"),
    time = as.hms(time_stamp, "%H:%M:%S"),
    year = as.factor(year(date)),
    month = as.factor(month(date)),
    version_number = str_replace(version_number, "^(\\d{1,2}.\\d{1,2}.\\d{1,2})(\\w+)$", "\\1-\\2")
  )
```

```{r, include=FALSE}
data <- add_column(
  data,
  pull(
    data, version_number) %>%
    semver::parse_version() %>%
    as.data.frame() 
    ) %>%
  arrange(major, minor, patch)
```

```{r, include=FALSE}
data <- data %>%
  mutate(
    version_type = ifelse(prerelease != "", "pre-release",
                           ifelse(minor == "0" & patch == "0", "major",
                                   ifelse(patch == "0", "minor", "patch"))))
```

## Exploring the data

### Number of versions

As of today, the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) uses a total of 72 packages which were updated in a total of 7,461 versions since December 29th, 2010. Those updates included major versions, minor versions, patches and pre-release versions. 

**Figure 1** demonstrates that most of the updates between December 2010 and December 2020 were patches (40.4%), followed by pre-release versions (36.2%), minor versions (19.8%) and finally, major versions (3.6%).

```{r, echo=FALSE}
data %>%
  group_by(version_type) %>%
  summarise(n = n()) %>%  
  mutate(percent = round((n / sum(n) * 100), 1)) %>%
  ggplot(aes(version_type, percent)) +
  geom_col(colour = "black", fill = "white") +
  theme() +
  labs(
    title = "Figure 1: Breakdown of types of versions between December 2010 and 2020", 
    x = "Version type", 
    y = "Percent of all versions"
  ) +
  geom_text(aes(label = paste0(percent, "%", " (", n, ")"), y = percent),
            vjust = 1.4, size = 4, color = "black")
```

I then removed the pre-release versions from the remaining of the analysis as I was mainly interested in the maintenance of the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) once in production leaving a total of 4,763 versions including major, minor and patches. **Figure 2** demonstrates that the number of stable versions (major, minor and patches) increased between 2010 and 2015 but has been relatively stable since then.

```{r, echo=FALSE}
data %>%
  filter(version_type != "pre-release") %>%
  ggplot(aes(x=year, fill=version_type)) +
  geom_bar(colour = "black") +
  scale_fill_manual(name = "version type:", values=c("#f1faee","#a8dadc","#457b9d","#1d3557")) +
  labs(
    title = "Figure 2: Number of versions per year", 
    x = "Year", 
    y = "Number of versions"
  )
```

**Figure 3** is a plot of the number of versions (major, minor and patches) for each package since December 29th, 2010. The package with the most versions is at the top (webpack with 319 versions) and the package with the least versions is at the bottom (webpack-config-utils with 6 versions). **Figure 3** demonstrates the variability in the number of versions among packages. Note that not all packages existed in December 2010 and the creation date of packages might account for some of this variability.

```{r, fig.height=18, echo=FALSE}
data %>% 
  filter(version_type != "pre-release") %>%
  count(package_name, sort = TRUE) %>%
  mutate(package_name = fct_reorder(package_name, n)) %>%
  ggplot(aes(n, package_name)) +
  geom_col(colour = "black", fill = "white") +
  labs(
    title = "Figure 3: Number of versions for each package",
    x = "Number of versions (majors, minors, patches and pre-releases)", 
    y = "Package name"
  )
```

**Figure 2** is a heatmap of the number of versions per year per package with packages organised in alphabetical order on the y-axis. The more versions in a year for a given package, the darker the color (see legend). This figure demonstrates that packages were created in every year between 2011 and 2019 and that the number of versions per package per year is highly variable among packages and years. Some packages had most of their versions in the early years after their creation and are no longer updated (e.g., babel-core), others had most versions in recent years (e.g., eslint-plugin-react) and others had no clear trends (e.g., d3). Also note that since 2018, some packages switched to [scope packages](https://docs.npmjs.com/cli/v6/using-npm/scope) such as babel-core which is now ["@babel/core"](https://babeljs.io/docs/en/v7-migration#scoped-packages). For the purpose of this analysis, those packages are treated as different packages. 

```{r, fig.height=18, echo=FALSE}
heatmap_data <- data %>% group_by(year, package_name) %>% tally()

heatmap_data %>% 
  ggplot(mapping = aes(x = year, y = reorder(package_name, desc(package_name)), fill = n)) +
  geom_tile(colour = "black") +
  labs(
    title = "Figure 2: Number of versions per year per package",
    x = "Year", 
    y = "Package name"
  ) +
  scale_fill_gradient(name = "# of versions",
                      low = "white",
                      high = "black") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  theme(axis.text.x = element_text(angle = 90))
```

**Figure 3A** illustrates the number of packages used in the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) that existed per year between December 29th, 2010 and December 31st, 2020 while **Figure 3B** illustrates the total number of versions per year for the same period of time. The number of packages increased between 2011 and 2018 but appears to have stabilised since while the number of versions appears to be more or less stable since 2015.

```{r, echo=FALSE}
plot_packages <- data %>%
  group_by(year) %>%
  summarise(number_of_packages = n_distinct(package_name)) %>%
  ggplot(aes(year, number_of_packages)) +
  geom_col(colour = "black", fill = "white") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(
    x = "Year", 
    y = "Number of packages"
  )

plot_versions <- data %>%
  group_by(year) %>%
  tally() %>%
  ggplot(aes(year, n)) +
  geom_col(colour = "black", fill = "white") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(
    x = "Year", 
    y = "Number of versions (major, minor and patches)"
  )

plot_grid(plot_packages, plot_versions, labels = c('3A', '3B'))
```

**Figure 4A** illustrates the number of versions (major, minor and patches) per package used in the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) per year between December 2010 and November 2020. **Figure 4B** focuses on the number of major versions per package per year. Note that at the time of writing this, the year 2020 was not complete.

```{r, echo=FALSE}
plot_all_versions_per_package_per_year <- data %>%
  group_by(year) %>%
  summarise(
    number_of_versions = n(),
    number_of_packages = n_distinct(package_name),
    number_versions_per_package = number_of_versions / number_of_packages
            ) %>%
  ggplot(aes(year, number_versions_per_package)) +
  geom_col(colour = "black", fill = "white") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(
    x = "Year", 
    y = "Number of versions (all) per package"
  )

plot_major_versions_per_package_per_year <- data %>%
  group_by(year) %>% 
  filter(minor == "0") %>% 
  filter(patch == "0") %>%
  summarise(
    number_of_versions = n(),
    number_of_packages = n_distinct(package_name),
    number_versions_per_package = number_of_versions / number_of_packages
            ) %>%
  ggplot(aes(year, number_versions_per_package)) +
  geom_col(colour = "black", fill = "white") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(
    x = "Year", 
    y = "Number of major versions per package"
  )

plot_grid(plot_all_versions_per_package_per_year, plot_major_versions_per_package_per_year, labels = c('4A', '4B'))
```

### Time between major versions

In theory, minor versions and patches do not require code changes but major versions do. Since December 2010, there were 262 major versions of the packages used in the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json), representing less than 4% of all versions. **Figure 5** illustrates the distribution of the time between major versions by year. In this figure and in the table below, We can see that the long periods between major versions occured in 2011 (585 days) and 2012 (210 days). We can also see that the median and the average time between the major versions were highly variable before 2015. 

```{r, include=FALSE}
major_versions_only <- data %>% 
  filter(minor == "0") %>% 
  filter(patch == "0")
```

```{r, include=FALSE}
interval_between_major_versions_only <- major_versions_only %>%
   mutate(major_version = paste0(package_name, " ", major, ".", minor, ".", patch)) %>% 
   arrange(time_stamp) %>%
   mutate(
     days_until_next_major_version = as.numeric(lead(date) - date)
   ) %>%
  drop_na(days_until_next_major_version) 
```

```{r, echo=FALSE}
interval_between_major_versions_only %>% 
  ggplot(aes(x=days_until_next_major_version)) +
  geom_histogram(boundary = 0, binwidth = 20, colour = "black", fill = "white") + 
  labs(
    title = "Figure 5: Distribution of time between major versions (by year)",
    x = "Time (days) between major versions",
    y = "Count"
  ) +
  facet_wrap(~ year)
```

```{r, include=FALSE}
table <- interval_between_major_versions_only %>% 
  group_by(year) %>%
  summarise(
    number_of_major_versions = n(), 
    median_time = median(days_until_next_major_version),
    average_time = mean(days_until_next_major_version),
    standard_deviation = sd(days_until_next_major_version)
  ) 
```

```{r, echo=FALSE}
formattable(
  table,
  align =c("l","c","c","c","c")
  )
```

**Figure 2** also illustrates that updates to packages starting with @ all started in 2018. The use of the @ in a package name at the beginning of a packages name is refered to as [scopes](https://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages). Given the variation in earlier years, and the introduction of several packages in 2018, the years 2018 and 2019 would be the most representative of the time between major version once the he the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) will be in production. **Figure 6** illustrates the distribution of the time between major versions in 2018 and 2019 and **Figure 7** illustrates the same for both years pulled together. In those two years, the average time between major version was 8 days and the median was 4 days.

```{r, echo=FALSE}
interval_between_major_versions_only %>% 
  filter(date >= "2018-01-01") %>%
  filter(date < "2020-01-01") %>%
  ggplot(aes(x=days_until_next_major_version)) +
    geom_histogram(boundary = 0, binwidth = 5, colour = "black", fill = "white") + 
    scale_x_continuous(breaks = seq(0, 50, by = 5)) +
    facet_wrap(~ year) +
    labs(
      title = "Figure 6: Distribution of time between major versions (2018 and 2019)",
      x = "Time (days) between major versions",
      y = "Count"
    )
```

```{r, echo=FALSE}
interval_between_major_versions_only %>% 
  filter(date >= "2018-01-01") %>%
  filter(date < "2020-01-01") %>%
  ggplot(aes(x=days_until_next_major_version)) +
    geom_histogram(boundary = 0, binwidth = 5, colour = "black", fill = "white") + 
    scale_x_continuous(breaks = seq(0, 50, by = 5)) +
    labs(
      title = "Figure 7: Distribution of time between major versions (2018 and 2019)",
      x = "Time (days) between major versions",
      y = "Count"
    ) 
```

```{r, include=FALSE}
interval_between_major_versions_only %>% 
  filter(date >= "2018-01-01") %>%
  filter(date < "2020-01-01") %>%
  summarise(
    number_of_major_versions = n(), 
    median_time = median(days_until_next_major_version),
    average_time = mean(days_until_next_major_version),
    standard_deviation = sd(days_until_next_major_version)
  ) 
```

The two figures below illustrates major version over the years of 2018 and 2019. 

```{r, echo=FALSE}
timeline_2018 <- interval_between_major_versions_only %>% 
  filter(date >= "2018-01-01") %>%
  filter(date < "2019-01-01") %>%
  ggplot(aes(x=date)) +
    geom_bar() + 
    labs(
      x = "Date in 2018",
      y = "Number of major versions"
    )

timeline_2019 <- interval_between_major_versions_only %>% 
  filter(date >= "2019-01-01") %>%
  filter(date < "2020-01-01") %>%
  ggplot(aes(x=date)) +
    geom_bar() + 
    labs(
      x = "Date in 2019",
      y = "Number of major versions"
    )

plot_grid(timeline_2018, timeline_2019, ncol = 1)
```

## Conclusions

Once completed, the programmers that developed the [dependency manifest file](https://github.com/canada-ca/tracker/blob/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json) can expect major updates to their dependancies every 4 to 8 days.

## Methods

### Writing the data to a JSON file

The manifest was retrieved using [curl](https://curl.se/) with the following command on January 1, 2021.
```
curl -sL "https://raw.githubusercontent.com/canada-ca/tracker/003a3d6e0452fb9a248a7d51fd5556bc03dfbcc6/frontend/package.json" > data/raw/tracker-frontend-package.json
```
### Converting the data to a CSV file
Using the following [Bash](https://www.gnu.org/software/bash/) command, package names (both development and production) were extracted from the `tracker-frontend-package.json` and details for each was retrieved from the npm API.

The command uses [jq](https://stedolan.github.io/jq) to select dependency name from the json and format the API response as CSV. Once again `curl` was used to retrieve data from the API.
```
for pkg in $(cat data/raw/tracker-frontend-package.json | jq '.dependencies * .devDependencies | keys[]' | tr -d \"); do $(curl -sL "https://registry.npmjs.org/$pkg" | jq -r --arg  name "$pkg" '.time | to_entries[] | [$name, .key, .value] | @csv' >> data/processed/nodejs.csv && sleep 1 ); done
```

The CSV contained the name of the package, the version and a time stamp.

### Cleaning the CSV file

The data needed a little attention before conducting analysis. The reader is referred to the [Rmarkdown file](https://github.com/caromimo/dependency-analysis/blob/master/index.Rmd) for code and details. 

Briefly, the data was cleaned in the four main steps:

1. read the CSV file and specify column names;
2. removed rows that did not contain data - for each package, the "time" returned a series of keys (version numbers but also a "created" and a "modified") and values (time stamp) - it was assumed that the row with "created" and the earliest version of a package were on the same day and that the "modified" and the latesst version of a package were on the same day; 
3. extracted the date from the time stamp, extracted the year as a factor, extracted the month as a factor, extracted the day of the week as a factor and parsed the version number to only include the first three numbers and the dots separating the numbers; and
4. extracted the version numbers into separate columns for major, minor and patch versions using the semver library.

The cleaned dataset contains the following 12 columns: package_name, version, time_stamp, date, time, year, month, major, minor, patch, prerelease, and build.

## Acknowledgments

Thank you M. Williasom for the inspiration and the raw data and L. Puts for the help with plots.